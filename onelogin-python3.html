<h2 id="setuppythonsaml" class="how-to-title">Set-up OneLogin library</h2>
<p>ITS requires all service providers to send its authentication requests over SSL. This means SAML can only be used with servers that serve the web application over secure HTTP (HTTPS).</p>

<p>These instructions try to follow the installation guide of Python3-SAML provided in the <a href="https://github.com/onelogin/python-saml" target="_blank">readme of the package</a>, but tries to help configuring the service provider exactly to the needs of ITS' identity provider</p>

<p>Do note that even for Python various implementations of SAML exist. E.g. <a href="https://github.com/rohe/pysaml2" target="_blank">PySAML2</a> or <a href="https://bitbucket.org/lgs/djangosaml2/overview" target="_blank">DjangoSaml2</a>. A library worth especially worth mentioning is <a href="https://github.com/fangli/django-saml2-auth" target="_blank">Django SAML2 Auth</a>, a library integrating the Service Provider into Django with minimal configuration required. Whether this implementation works with the IdP configuration maintained by ITS is, however, not verified, but if your current application uses Django authentication, this library might be worthwhile to explore.</p>
<p>The reason OneLogin's Python-SAML library is elaborated here is that it is a Python-general library that can be used in any Python framework, it is well documented and OneLogin has implementations for many other languages that follow roughly the same procedures. The last of these arguments means that if this how-to is succesful, it can more easily be generalized to implementations for other languages than is the case with other libraries</p>

<p>In this tutorial, the name <var>hostname</var> will be used for the base URL of the web application. The name <var>saml_location</var> will be used for the absolute path saml is installed in. The name <var>saml_url</var> will be used for the url path to the saml service provider (as <var>hostname/saml_url</var>).</p>

<ol>
<li>
	<p>Depending on which configuration you use, any of these packages may be required:</p>
	<p>
		<ul>
			<li>Linux packages:
				<ul>
					<li>libxml2</li>
					<li>libxml2-dev</li>
					<li>libxlst1-dev</li>
					<li>python-dev</li>
					<li>pkg-config</li>
					<li>libxmlsec1-dev</li>
					<li>lib-apache2-mod-wgsi (if you want to serve your python application through apache</li>
				</ul>
			</li>
			<li>Python (pip) packages:
				<ul>
				    <li>xmlsec</li>
			    	<li>isodate</li>
			    	<li>defusedxml</li>
				</ul>
			</li>
		</ul>
		</p>
	<p>If you already use Django or a similar framework, you will most likely already have these packages installed</p>
</li>
<li><p>Installing OneLogin Saml-3 is as simple as running a pip command:</p>
<p><pre><code class="sh">$ pip install python-saml</code></pre> or <pre><code class="sh">$ pip install python3-saml</code></pre>, depending on the Python version you run your application with.</p>
<p>Make sure to use the pip version corresponding to the python version (the eternal 2 vs. 3 debate) and to run the command in your virtual environment if you are using one</p><p>You may also simply add <i>python-saml</i> to your dependencies if you are using dependancy management.</p></li>

<li><p>Inside your project, create a folder named <i>saml</i>. Within this folder, you need to create two files, <i>settings.json</i> and <i>advanced_settings.json</i>, and one directory, <i>certs</i>.</p></li>
<li><p>Open the file <i>settings.json</i> you just created for editing. In the <a href="https://github.com/onelogin/python3-saml" target="_blank">readme of the python-saml repository</a> you can find complete specifications for all options in this file. However, you can use the following template as a minimal configuration. These options are at the very least required:</p>
<pre><code class="json">{
    "strict": true,
    "debug": false,
    "sp": {
        "entityId": "https://hostname/saml/metadata/",
        "assertionConsumerService": {
            "url": "https://hostname/saml/acs/",
            "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST"
        },
        "singleLogoutService": {
            "url": "https://hostname/saml/sls/",
            "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
        },
        "NameIDFormat": "urn:oasis:names:tc:SAML:2.0:nameid-format:transient"
    },
    "attributeConsumingService": { },
    "idp": {
        "entityId": "<span class="namidp-metadata-link">https://namidp.services.uu.nl/nidp/saml2/metadata</span>",
        "singleSignOnService": {
            "url": "https://<span class="idp-base-link">anamidp.services.uu.nl</span>/nidp/saml2/sso",
            "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
        },
        "singleLogoutService": {
            "url": "https://<span class="idp-base-link">anamidp.services.uu.nl</span>/nidp/saml2/slo",
            "binding": "urn:oasis:names:tc:SAML:2.0:bindings:HTTP-Redirect"
        },
        "x509cert": ""
    }
}</code></pre>
	<ol>
		<li>Replace all occurences of <i>hostname</i> with the host name of your web application</li>
		<li>Optionally, change the value of <b>serviceName</b> and <b>serviceDescription</b> to a name and description of your liking. The name should not contain any spaces and should be as simple as possible. After you have requested access to the IdP from ITS, changing this value will cause SAML to stop working.</li>
		<li><p>If you already have the public key of the IdP you register on (either their acceptation IdP or their production IdP) you can add the contents to the value of <b>x509cert</b> inside the <b>idp</b> class of this file.</p>
		<p>If you do not have this yet, contact ITS to ask for it, or go to <a href="https://namidp.services.uu.nl/nidp/saml2/metadata" target="_blank" class="namidp-metadata-active-link">https://namidp.services.uu.nl/nidp/saml2/metadata</a> and use the value of <b>ds:X509Certificate</b> in the node <b>ds:KeyInfo</b>. You will have to remove the line endings before adding the contents of this key to your json file</p>
		<p>If that is unclear, you can always e-mail ITS and ask for the public key for their IdP (mention if you want the acceptation IdP or the production IdP)</p></li>
		<li>You can change the values of <b>strict</b> and <b>debug</b> to <i>false</i> and <i>true</i> respectively for debugging purposes, but make sure those values are as indicated above when your application runs in production status</li>
	</ol>
	<p>Do note that the <b>attributeConsumingService</b> shown in the example in the readme does not work with the IdP of ITS. Instead, you should ask ITS for access to the attributes you need. However, the value is still required in the <i>settings.json</i> file, so do not remove it.</p>
</li>

<li><p>Open the file <i>advanced_settings.json</i> you just created for editing. You can insert the following template:</p>
<pre><code class="json">{
    "security": {
        "nameIdEncrypted": false,
        "authnRequestsSigned": true,
        "logoutRequestSigned": true,
        "logoutResponseSigned": false,
        "signMetadata": false,
        "wantMessagesSigned": false,
        "wantAssertionsSigned": false,
        "wantNameId" : true,
        "wantNameIdEncrypted": false,
        "wantAssertionsEncrypted": false,
        "signatureAlgorithm": "http://www.w3.org/2000/09/xmldsig#rsa-sha1",
        "metadataValidUntil" : "2027-03-06T09:00:30Z",
        "requestedAuthnContext" : false
    },
    "contactPerson": {
        "technical": {
            "givenName": "technical_name",
            "emailAddress": "technical@example.com"
        },
        "support": {
            "givenName": "support_name",
            "emailAddress": "support@example.com"
        }
    },
    "organization": {
        "en-US": {
            "name": "default-sp",
            "displayname": "default-sp",
            "url": "https://hostname/saml"
        }
    }
}</code></pre>
	<ol>
		<li>Replace all occurences of <i>hostname</i> with the host name of your web application</li>
		<li>Replace all values in <b>ContactPerson</b> and <b>organization</b> to your own needs</li>
	</ol>
</li>

<li>
<p>Inside the <i>saml/certs</i> folder you created earlier, there should the public and private components of a key that SAML can use to sign requests.</p><p>You can use existing keys if they follow the X.509 standard (e.g. your SSL certificate), or you can generate a new private and public key. Make sure to cal them <i>sp.key</i> and <i>sp.cert</i> respectively. If you wish to generate your own keys, you can use the following command:</p>
<pre><code class="bash">$ openssl req -newkey rsa:2048 -new -x509 -days 3652 -nodes -out sp.crt -keyout sp.key</code></pre>
<p>Fill out the information that this command asks for as fits your application.</p>
<p>Once you have done this and placed them in the <i>saml/certs</i> directory, python-saml should automatically pick them up.</p>
</li>
</ol>

<h2 id="onelogin-preparing-application">Preparing your application</h2>
<p>To start using SAML in your application, you have to load the various classes. Where you do this depends on the framework you use. Minimal demos are provided by OneLogin for the <a href="https://github.com/onelogin/python3-saml/tree/master/demo-django" target="_blank">Django</a>, <a href="https://github.com/onelogin/python3-saml/tree/master/demo-flask" target="_blank">Flask</a> and <a href="https://github.com/onelogin/python3-saml/tree/master/demo_pyramid" target="_blank">Pyramid</a> frameworks. The following section largely uses examples from the django demo, but tries to elaborate a bit more on what to implement and why. The code may have been adapted to fully work with the ITS IdP.</p>
<h3 id="onelogin-auth-object">Setting up the <i>auth</i> object</h3>
<p>Python-SAML works largely from a singly object that you need in your code: the <i>auth</i> object. This object is constructed from a request (from Django, Flask, Pyramid, etc) and can be used to process the response sent by the IdP, authenticate users and extract attributes of the signed in user.</p>

<p>In order to use Python-SAML in your project, you need to load the appropriate libraries:</p>

<p><pre><code class="python">from onelogin.saml2.auth import OneLogin_Saml2_Auth
from onelogin.saml2.settings import OneLogin_Saml2_Settings
from onelogin.saml2.utils import OneLogin_Saml2_Utils
</code></pre></p>

<p>Once these libraries are loaded, the <i>auth</i> object can be constructed. This object takes two parameters: A dictionary containing request information and the full path to your saml settings directory. The latter is the location where you placed your <i>certs</i> directory and your .json files. The former has the following general form:</p>
<p><pre><code class="python">req = {
    "http_host": "",
    "script_name": "",
    "server_port": "",
    "get_data": "",
    "post_data": ""
}</code></pre></p>
<p>All these parameters are about your server. So <i>http_host</i> is your server address (in previous section indicated as <i>hostname</i>), <i>script_name</i> is the path to the specific script being executed (or page being loaded) and <i>server_port</i> is the port through which your server can be accessed. If you are using an SSL connection, this will most likely be 443.</p>
<p>In most frameworks, this dictionary can be extracted from the framework itself. E.g. in Django you would use the following function:</p>
<p><pre><code class="python">def prepare_from_django_request(request):
    return {
        'http_host': request.META['HTTP_HOST'],
        'script_name': request.META['PATH_INFO'],
        'server_port': request.META['SERVER_PORT'],
        'get_data': request.GET.copy(),
        'post_data': request.POST.copy()
    }
</code></pre></p>
<p>How to do this for other frameworks is shown in the various demos linked earlier.</p>
<p>The auth object can be created like this:</p>
<p><pre><code class="python">auth = OneLogin_Saml2_Auth(req, custom_base_path='/path/to/saml/configuration/')</code></pre></p>
<p>You will need this auth object on any page you want to use SAML features on, so you might want to create a function that will generate this object automatically from the request object of your framework. The rest of this documentation will assume a function called <i>init_saml_auth(req)</i>, which creates the auth object from the req dictionary as indicated above. Further examples will be based on the Django framework, but an attempt will be made to generalize the code as much as possible.</p>

<h3 id="onelogin-metadata-page">Creating a Metadata page</h3>
<p>In order to have ITS add your Service Provider (SP) to their Identity Provider (IdP), they will need an overview of your metadata. This metadata is automatically generated by Python-SAML using the following code (although there are various other ways of doing this as well):</p>
<p><pre><code class="python">auth = init_saml_auth(request)
saml_settings = auth.get_settings()
metadata = saml_settings.get_sp_metadata()
errors = saml_settings.validate_metadata(metadata)
if len(errors) == 0:
    print metadata
else:
    print "Error found on Metadata: %s" % (', '.join(errors))
</code></pre></p>

<p>An XML version of this output should be located at the address set for the <b>entityID</b> which you set in the <i>settings.json</i> file. In the example, this was https://hostname/saml/metadata/</p>
<p>In Django, this view could be created as follows (notice a different method of creating the SAML settings object, using the <i>settings.SAML_FOLDER</i> parameter that refers to the <i>settings.py</i> file and should point to the full path of your saml configuration):</p>
<p><pre><code class="python">def metadata(request):
    saml_settings = OneLogin_Saml2_Settings(
    	settings=None, 
    	custom_base_path=settings.SAML_FOLDER, 
    	sp_validation_only=True
    )
    metadata = saml_settings.get_sp_metadata()
    errors = saml_settings.validate_metadata(metadata)

    if len(errors) == 0:
        resp = HttpResponse(content=metadata, content_type='text/xml')
    else:
        resp = HttpResponseServerError(content=', '.join(errors))
    return resp
</code></pre></p>

<p>Once you have done this, you can go to your metadata location (e.g. https://hostname/saml/metadata) and check if you receive any errors. If not, make sure <b>ds:X509Certificate</b> in the KeyDescriptor has a value. If so, your key files seem to be working correctly.</p>


<h2 id="onelogin-contact-ITS">Contact ITS</h2>
<p>You should now contact ITS and ask them to add your Service Provider to their Identity Provider. Save the metadata as an XML file and send this file to ITS, along with the message that you want to register your application with their Identity Provider. Give the base URL of your application and say if you want to make use of their acceptation or production Identity Provider (depending on what URL you entered in <i>settings.json</i> file).</p>
<p>Also indicate which fields you want the Identity Provider to pass back with a successful authentication redirect (such as solis-ID, full name, e-mail address, etc).</p>
<p>Once they have added you, you should be able to use SAML for authenticating your users.</p>

<h2 id="onelogin-use-in-project">Using OneLogin in your project</h2>
<h3 id="onelogin-authenticate">Authenticate users in your Python application</h3>
<p>To authenticate users, you have to send an <i>authentication request</i> to the single sign on (SSO) service of the IdP. You have already configured everything Python-SAML needs in the <i>settings.json</i> file, so the URL to send this request to can be generated from the <i>login()</i> function of the auth object. Lets say the user should be authenticated right away when they visit the index page of your site. The Django code would look like this:</p>
<p><pre><code class="python">def index(request):
    req = prepare_from_django_request(request)
    auth = init_saml_auth(req)
    url = auth.login()
    
    # Redirect the user to this url (exact method depends on framework)
    return HttpResponseRedirect(url) 
</code></pre></p>
<p>This code will redirect the user to the SAML login page configured in the IdP. If the user logs in succesfully, she will be redirected back to the Attribute Customer Service (ACS) of your service provider, where the authentication can be processed. This last redirect makes use of the POST method. The important information is encoded as POST data.</p>

<p>If you want the user to end up on a different page than your ACS page after they have authenticated, you can add the <i>return_to</i> parameter to the <i>login</i> function (in this example in your index function):</p>
<p><pre><code class="python">target_url = 'where-you-want-to-send-the-user.example.org'
auth.login(return_to=target_url)
</code></pre></p>
<p>Along with the <i>return_to</i> parameter, the login method accepts three other names parameters:
<ol><li><b>force_authn</b>: If set to <i>True</i>, the user will be forced to enter their credentials. Usually this is not required if the user is already signed in to the IdP, either on this application or on another application in the same browser.</li>
<li><s><b>is_passive</b>: This is the opposite of <i>force_authn</i>; if the user is already logged in to the IdP, the user will not have to enter their credentials, even if they did not yet log in to this specific application</s> (Not supported by the ITS IdP)</li>
<li><b>set_nameid_policy</b>: If set to true, the name ID policy will be added to the login request sent to the IdP. For the current configuration of the ITS IdP this does not add anything useful.</li>
</ol>

<h3 id='onelogin-process-response'>Process the authentication response</h3>
<p>The location of your ACS is configured in the <i>settings.json</i> file, but it still has to be implemented. In the example above, the location of the ACS is <i>https://hostname/saml/acs/</i>, so in this case, the ACS needs to be implemented on the <i>acs</i> endpoint.</p>
<p>The ACS will process the information sent back by the IdP. Lets create the acs endpoint in Django:</p>
<p><pre><code class="python">def acs(request):
    req = prepare_from_django_request(request)
    auth = init_saml_auth(req)
    auth.process_response() # This is the magic of checking the IdP response
    errors = auth.get_errors() # If something went wrong, we will know
    status = "Not authenticated"
    if len(errors) == 0:
        if auth.is_authenticated(): #this will only work on a response object
            # So we have to remember if the user already authenticated
            request.session['samlUserdata'] = auth.get_attributes()
            # We also need the NameID provided by the IdP in case we want to send a followup request
            request.session['samlNameId'] = auth.get_nameid()
            # And for good measure, let's save the session index as well
            request.session['samlSessionIndex'] = auth.get_session_index()

            if 'RelayState' in req['post_data'] and 
              OneLogin_Saml2_Utils.get_self_url(req) != req['post_data']['RelayState']:
                # If the authentication request was accompanied by a relay state, i.e. an
                # url to send the user to after authentication, redirect there
                auth.redirect_to(req['post_data']['RelayState'])
        else:
            status = "Authentication failed"
    else:
        status = str(len(errors)) + " errors: " + str(errors)

    return HttpResponse(status) # Unless a relay state was given
</code></pre></p>
<p>Notice the function call <i>is_authenticated()</i> on the auth object. This call will only work after <i>process_response()</i> is called and an actual response is available. Because this response is not stateless (i.e. no longer exists after the user navigates to a different page) this call can not always be made. To verify the authentication status of the user on later pages, the required information is stored in the session data.</p>

<p>Notice also that we extract the <i>Name ID</i> from the response object. This is because the configuration ITS has set for its IdP requires the Name ID to be sent back with every following request. This is especially important if you want to send a logout request.</p>
<p>Now that the data is stored in the session, you can use it anywhere. The various demos provided by OneLogin provide a separate page where the authenticated user can check her own attribute values.</p>
<h3 id='onelogin-check-auth-status'>Checking if the user is logged in</h3>
<p>On any page that does not have direct access to the login response, you can check if the user is logged in by checking if the key <i>samlUserdata</i> is in your session data. If you want to verify authentication on other pages in a different manner, make sure to set this up in the acs.</p>
<p>An example page to print the user attributes only if they are logged in could look like this (in Django):</p>
<p><pre><code class="python">def attributes(request):
    req = prepare_from_django_request(request)
    if 'samlUserdata' in request.session:
        lst = "&lt;ul&gt;"
        for k in request.session['samlUserdata'].keys():
            lst += "&lt;li&gt;{0}: &lt;b&gt;{1}&lt;/b&gt;&lt;/li&gt;".format(k, ', '.join(request.session['samlUserdata'][k]))
        lst += "&lt;/ul&gt;"
        lst += "&lt;a href=\"{0}\">Logout&lt;/a&gt;".format(OneLogin_Saml2_Utils.get_self_url(req) + reverse(logout))
    else:
        lst = "You are not authenticated. Login <a href=\"{0}\">here</a>".format(OneLogin_Saml2_Utils.get_self_url(req))
    return HttpResponse(lst)
</code></pre></p>
<h3 id="python-logout">Logout the user</h3>
<p>The process for a user to logout of your application consists of two parts, similar to the login: A logout request is sent to the IdP, and the IdP response is then processed on your application.</p>
<p>To send a logout request:</p>
<p><pre><code class="python">def logout(request):
    req = prepare_from_django_request(request)
    auth = init_saml_auth(req)

    # Start building the logout request
    name_id = None
    session_index = None

    # Both these parameters are required by the ITS IdP!
    if 'samlNameId' in request.session:
        name_id = request.session['samlNameId']
    if 'samlSessionIndex' in request.session:
        session_index = request.session['samlSessionIndex']

    logouturl = auth.logout(
        name_id=name_id, 
        session_index=session_index,
        return_to='<span class="namidp-logout-link" title="" data-original-title="On acceptation: http://logout.acc.uu.nl"><span class="hljs-string">http://logout.uu.nl</span></span>'
    )

    return HttpResponseRedirect(logouturl)
</code></pre></p>
When the user navigates to this endpoint, she will be redirected to the IdP with a logout request. The IdP will process this response and, if succesful, return the user to the Single Logout Service (SLS) endpoint of your SP. In the <i>settings.json</i> file we defined this as <i>https://hostname/saml/sls/</i> so in this case our SLS should be located at the <i>sls</i> endpoint:</p>
<p><pre><code class="python">def sls(request):
    req = prepare_from_django_request(request)
    auth = init_saml_auth(req)

    # create a passable function that flushes the session data.
    # At least make sure the session values you use to check if
    # your user is still authenticated are deleted, so when the
    # user goes back to your page, she has to login again
    dscb = lambda: request.session.flush()

    url = auth.process_slo(delete_session_cb=dscb)
    
    errors = auth.get_errors()
    if len(errors) == 0:
        if url is not None:
            return HttpResponseRedirect(url)
        else:
            success_slo = True
</code></pre></p>